package com.macys.sdt.framework.runner;

import com.macys.sdt.framework.interactions.Navigate;
import com.macys.sdt.framework.interactions.Wait;
import com.macys.sdt.framework.utils.EnvironmentDetails;
import com.macys.sdt.framework.utils.StepUtils;
import com.macys.sdt.framework.utils.Utils;
import com.macys.sdt.framework.utils.analytics.DATagCollector;
import com.macys.sdt.framework.utils.analytics.PageLoadProfiler;
import cucumber.api.cli.Main;
import net.lightbody.bmp.BrowserMobProxy;
import org.junit.Assert;
import org.openqa.selenium.WebDriverException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.net.ServerSocket;
import java.util.*;

import static com.macys.sdt.framework.utils.StepUtils.stopPageLoad;
import static java.lang.Runtime.getRuntime;
import static com.macys.sdt.framework.runner.RunConfig.*;

/**
 * This class handles the configuration and running of cucumber scenarios and features
 */
public class MainRunner {

    private static final Logger logger;

    /**
     * BrowserMob proxy server
     */
    public static BrowserMobProxy browsermobServer = null;

    /**
     * List containing URL's that have been visited
     */
    public static ArrayList<String> URLStack = new ArrayList<>();

    /**
     * The current URL of the browser
     */
    public static String currentURL = "";

    /**
     * Time the tests were started
     */
    public static long startTime = System.currentTimeMillis();

    /**
     * Current run status. 0 is good, anything else is bad
     */
    public static int runStatus = 0;

    // username and API key for main sauce labs account:
    // satish-macys 4fc927f7-c0bd-4f1d-859b-ed3aea2bcc40

    static {
        // this handles log config initialization before any logs are created
        RunConfig.init();
        logger = LoggerFactory.getLogger(MainRunner.class);
    }

    /**
     * Main method to run tests
     *
     * @param args run args. Only checked for cucumber config options as generated by intellij
     * @throws Throwable if an exception or error gets here, we're done
     */
    public static void main(String[] args) throws Throwable {
        // When test are aborted by user or EE, need to make sure sauce labs still gets driver quit command
        // This code should help with "Test did not see a new command for 300 seconds" error
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if (WebDriverManager.driverInitialized() && (closeBrowserAtExit || useSauceLabs)) {
                WebDriverManager.driver.quit();
            }
        }));

        getEnvVars(args);

        ArrayList<String> cucumberArgs = getFeatureScenarios();
        if (cucumberArgs == null) {
            throw new Exception("Error getting scenarios");
        }

        // add any tags
        String tags = getEnvOrExParam("tags");
        if (tags != null) {
            cucumberArgs.add("--tags");
            cucumberArgs.add(tags);
        }

        // attempt to use workspace as relative path to feature file (if needed)
        for (int i = 0; i < cucumberArgs.size(); i++) {
            String value = cucumberArgs.get(i);
            if (value.equals("--tags")) {
                break;
            }
            // remove windows drive to avoid incorrect matches on ":"
            String drive = "";
            if (value.matches("[A-Z]:.*?")) {
                drive = value.substring(0, 2);
                value = value.substring(2);
            }
            // remove any line number args
            value = value.split(":")[0];
            value = drive + value;
            // make sure file exists
            File featureFile = new File(value);
            if (!(featureFile.exists() || featureFile.getAbsoluteFile().exists())) {
                cucumberArgs.set(i, workspace + "/" + cucumberArgs.get(i));
            }
        }

        if (project != null) {
            cucumberArgs.add("--glue");
            cucumberArgs.add("com.macys.sdt.projects." + project);
        }

        cucumberArgs.add("--glue");
        cucumberArgs.add("com.macys.sdt.shared");
        cucumberArgs.add("--plugin");
        cucumberArgs.add("com.macys.sdt.framework.utils.SDTFormatter");
        cucumberArgs.add("--plugin");
        cucumberArgs.add("html:logs");

        // intellij cucumber config gives scenario name to differentiate between scenarios at runtime
        if (args != null && args.length > 0) {
            for (int i = 0; i < args.length; i++) {
                if (args[i].equals("--name")) {
                    cucumberArgs.add(args[i]);
                    cucumberArgs.add(args[i + 1]);
                }
                if (args[i].equals("--dry-run")) {
                    cucumberArgs.add(args[i]);
                    dryRun = true;
                }
                if (args[i].equals("--glue") && !args[i + 1].startsWith("com.macys.sdt.shared") && !args[i + 1].contains(project)) {
                    cucumberArgs.add(args[i]);
                    cucumberArgs.add(args[i + 1]);
                }
            }
        }

        List<String> deps = getDependencies(project);
        for (String dep : deps) {
            cucumberArgs.add("--glue");
            cucumberArgs.add(dep);
        }

        // check if dry-run passed as env or ex param
        if (!dryRun && booleanParam("dry-run")) {
            dryRun = true;
            cucumberArgs.add("--dry-run");
        }

        logger.info("Testing " + url + " on " +
                (useAppium ? device + " running " + (StepUtils.iOS() ? "iOS " : "Android ") + remoteOS : browser + " " + browserVersion)
                + (useSauceLabs ? " on Sauce Labs" : ""));

        new AuthenticationDialog();
        setBeforeNavigationHooks();
        setAfterNavigationHooks();
        EnvironmentDetails.loadEnvironmentDetails(url, false);

        try {
            Thread cucumberThread = new Thread(() -> {
                int status = 1;
                try {
                    status = Main.run(cucumberArgs.toArray(new String[cucumberArgs.size()]),
                            Thread.currentThread().getContextClassLoader());
                } catch (IOException e) {
                    logger.error("IOException in cucumber run: " + e);
                } finally {
                    runStatus = status;
                }
            });
            cucumberThread.setName("Cucumber");
            cucumberThread.start();
            if (!appTest) {
                PageHangWatchDog.init(cucumberThread);
            }
            cucumberThread.join();

        } catch (Throwable e) {
            e.printStackTrace();
            runStatus = 1;
        } finally {
            close();
            if (args != null) {
                System.exit(runStatus);
            }
        }
    }

    /**
     * Adds the default before navigation hooks
     */
    public static void setBeforeNavigationHooks() {
        Navigate.addBeforeNavigation(Wait::setWaitRequired);
        Navigate.addBeforeNavigation(PageLoadProfiler::startTimer);
    }

    /**
     * Adds the default after navigation hooks
     */
    public static void setAfterNavigationHooks() {
        Navigate.addAfterNavigation(WebDriverManager::getCurrentUrl);
        Navigate.addAfterNavigation(PageHangWatchDog::resetWatchDog);
        Navigate.addAfterNavigation(Wait::setWaitDone);
        Navigate.addAfterNavigation(PageLoadProfiler::stopTimer);
    }

    /**
     * It will initiate the close process for execution and quit the driver
     */
    private static void close() {
        if (browser.equals("none")) {
            return;
        }
        if (tagCollection) {
            DATagCollector.close();
        }

        if (WebDriverManager.driver != null) {
            logger.info("Closing driver...");
            if (useSauceLabs || closeBrowserAtExit) {
                WebDriverManager.driverQuit();
            }
        }
    }

    public static Timeouts timeouts() {
        return Timeouts.instance();
    }

    /**
     * Windows authentication dialog login
     */
    protected static class AuthenticationDialog extends Thread {
        private static ServerSocket socketMutex;

        public AuthenticationDialog() {
            String osName = System.getProperty("os.name").toLowerCase();
            if (getEnvOrExParam("require_authentication") == null) {
                logger.info("AuthenticationDialog not required");
                return;
            }
            if (!(Utils.isWindows() && browser.equals("firefox")) &&
                    !(Utils.isWindows() && browser.equals("chrome")) &&
                    !((Utils.isOSX() || (remoteOS != null && remoteOS.contains("OS X"))) && browser.equals("safari"))) {
                logger.info("AuthenticationDialog not required : "
                        + getEnvOrExParam("require_authentication")
                        + " : " + osName
                        + " : " + browser);
                return;
            }

            this.start();
            new Thread(() -> {
                switch (browser) {
                    case "firefox":
                        runFirefoxBackgroundMethod();
                        break;
                    case "safari":
                        runSafariBackgroundMethod();
                        break;
                    case "chrome":
                        runChromeBackgroundMethod();
                        break;
                }
            }).start();
        }

        protected static void runFirefoxBackgroundMethod() {
            Utils.threadSleep(4000, null);
            if (socketMutex == null) {
                logger.warn("Another Authentication monitoring background thread already exist.");
                return;
            }
            logger.info("Firefox Windows Authentication monitoring background thread started");

            Process p;
            String filePath = sharedResourceDir + "/framework/authentication_popup/windows_authentication_firefox.exe";

            while (true) {
                try {
                    p = getRuntime().exec(filePath);
                    Utils.ProcessWatchDog pd = new Utils.ProcessWatchDog(p, 5000, "runFirefoxBackgroundMethod()");
                    p.waitFor();  // wait for process to complete
                    pd.interrupt();
                } catch (Exception e) {
                    // ignore all errors
                }
                // wait 2 seconds
                Utils.threadSleep(2000, null);
            }
        }

        protected static void runSafariBackgroundMethod() {
            Utils.threadSleep(4000, null);
            if (socketMutex == null) {
                logger.warn("Another Authentication monitoring background thread already exist.");
                return;
            }
            logger.info("Authentication monitoring background thread started");

            String fileName;
            fileName = "mac_authentication_safari.app";
            Process p;
            String filePath = "/Applications/" + fileName;
            File f = new File(filePath);
            if (!f.exists()) {
                logger.warn("Authentication monitoring program '" + filePath + "' does not exit.");
                return;
            }

            filePath = "open -a " + filePath;

            while (true) {
                try {
                    p = getRuntime().exec(filePath);
                    Utils.ProcessWatchDog pd = new Utils.ProcessWatchDog(p, 20000, "runSafariBackgroundMethod()");
                    p.waitFor();  // wait for process to complete
                    pd.interrupt();
                } catch (Exception e) {
                    e.printStackTrace();
                    // ignore all errors
                }
                // wait 10 seconds
                Utils.threadSleep(10000, null);
            }
        }

        protected static void runChromeBackgroundMethod() {
            Utils.threadSleep(4000, null);
            if (socketMutex == null) {
                logger.warn("Another Authentication monitoring background thread already exist.");
                return;
            }
            logger.info("Chrome Windows Authentication monitoring background thread started");

            Process p;
            String filePath = sharedResourceDir + "/framework/authentication_popup/windows_authentication_chrome.exe";

            // chrome need workaround for the Chrome Authentication Required popup
            // check the current URL periodically and compare it with original URL
            String curl;
            String orgUrl = url;
            orgUrl = orgUrl.replace("https://", "");
            orgUrl = orgUrl.replace("http://", "");
            orgUrl = orgUrl.replace("www.", "");
            int width = -1;

            while (true) {
                Utils.threadSleep(4000, null);
                curl = WebDriverManager.getCurrentUrl();
                // current url is still the same domain, then skip
                if (curl.contains(orgUrl)) {
                    continue;
                }

                // current url is not empty (Chrome default), then skip
                if (!(curl.contains("data:") || curl.contains("xnchegrn"))) {
                    continue;
                }

                // there seems to be Chrome Authentication Required Popup
                try {
                    if (width == -1) {
                        width = WebDriverManager.driver.manage().window().getSize().width;
                        filePath = filePath + " " + width;
                    }
                    p = getRuntime().exec(filePath);
                    Utils.ProcessWatchDog pd = new Utils.ProcessWatchDog(p, 10000, "runChromeBackgroundMethod()");
                    p.waitFor();  // wait for process to complete
                    pd.interrupt();
                } catch (Exception e) {
                    // ignore all errors
                }
                // wait 10 seconds
                Utils.threadSleep(6000, null);
            }
        }

        public void run() {
            try {
                socketMutex = new ServerSocket(6999);
                socketMutex.accept();
            } catch (IOException e) {
                socketMutex = null;
            }
        }
    }

    /**
     * Watchdog for Web Page
     */
    public static class PageHangWatchDog extends Thread {
        private static final Logger logger = LoggerFactory.getLogger(PageHangWatchDog.class);
        private final static long TIMEOUT = (StepUtils.safari() || StepUtils.ie() ? 130 : 95) * 1000;
        private final static long PAUSE_TIMEOUT = 280 * 1000;
        private final static int MAX_FAILURES = 5;
        private static Thread cucumberThread;
        private static PageHangWatchDog hangWatchDog;
        private static int failCount;
        private static boolean pause;
        private static long pauseStartTime;
        private String currentUrl;
        private long ts;
        private static Thread workerThread;

        private PageHangWatchDog() {
            logger.info("Start PageHangWatchDog: " + new Date());
            this.reset(url);
            this.setDaemon(true);
            this.start();
        }

        public static void init(Thread t) {
            if (hangWatchDog == null) {
                hangWatchDog = new PageHangWatchDog();
                cucumberThread = t;
            }
        }

        public static void resetWatchDog() {
            hangWatchDog.reset(null);
        }

        public static void pause(boolean pause) {
            PageHangWatchDog.pause = pause;
            if (pause) {
                pauseStartTime = System.currentTimeMillis();
            } else {
                failCount = 0;
            }
        }

        private void reset(String url) {
            this.ts = System.currentTimeMillis();
            if (url != null) {
                this.currentUrl = url;
                failCount = 0;
            }
        }

        private void interruptCucumberThread() throws InterruptedException {
            logger.error("Timeout! Pushing things along...");
            if (workerThread.isAlive()) {
                workerThread.join(TIMEOUT);
            }
            workerThread = new Thread(() -> {
                cucumberThread.interrupt();
                this.reset(null);
                pause = false;
            });
            workerThread.start();
            workerThread.join(TIMEOUT);
        }

        public void run() {
            while (cucumberThread.isAlive()) {
                try {
                    if (!WebDriverManager.driverInitialized()) {
                        continue;
                    } else if (pause) {
                        if (System.currentTimeMillis() - pauseStartTime > PAUSE_TIMEOUT) {
                            interruptCucumberThread();
                        }
                        // if we've been waiting a while, send any browser command to prevent
                        // dropping the sauce labs connection
                        if (System.currentTimeMillis() - this.ts > TIMEOUT) {
                            WebDriverManager.getCurrentUrl();
                            this.reset(this.currentUrl);
                        }
                        continue;
                    }
                    String url = WebDriverManager.getCurrentUrl();
                    //logger.error("Watchdog tick:\n>old url: " + this.currentUrl + "\n>new url: " + url);
                    if (url.contains("about:blank")) {
                        continue;
                    }
                    if (url.equals(this.currentUrl)) {
                        if (System.currentTimeMillis() - this.ts > TIMEOUT) {
                            logger.error("timeout at " + this.currentUrl +
                                    ", " + (MAX_FAILURES - failCount) + " failures until exit");
                            failCount++;
                            if (workerThread.isAlive()) {
                                workerThread.join(TIMEOUT);
                            }
                            workerThread = new Thread(() -> {
                                try {
                                    stopPageLoad();
                                } catch (Exception e) {
                                    // sometimes IE fails to run js. Continue running.
                                } finally {
                                    Navigate.browserRefresh();
                                }
                            });
                            workerThread.start();
                            workerThread.join(TIMEOUT);

                            this.reset(null);
                            if (failCount > MAX_FAILURES) {
                                interruptCucumberThread();
                            }
                        }
                    } else {
                        this.reset(url);
                    }
                } catch (Exception ex) {
                    if (!pause && ex instanceof org.openqa.selenium.NoSuchSessionException) {
                        logger.error("Driver session is dead, exiting");
                        break;
                    } else if (ex instanceof InterruptedException) {
                        cucumberThread.stop();
                        Assert.fail("Browser unresponsive. Ending test");
                    } else if (!(ex instanceof WebDriverException)) {
                        // WebDriverException thrown when we have a sync issue in IE
                        logger.error(ex.getMessage());
                        ex.printStackTrace();
                    }
                } finally {
                    //logger.info(pause ? "|" : "~");
                    Utils.threadSleep(5000, this.getClass().getSimpleName());
                }
            }
        }
    }
}
